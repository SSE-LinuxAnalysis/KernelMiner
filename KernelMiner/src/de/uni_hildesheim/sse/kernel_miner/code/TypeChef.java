package de.uni_hildesheim.sse.kernel_miner.code;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.ProcessBuilder.Redirect;
import java.util.ArrayList;
import java.util.List;

import de.uni_hildesheim.sse.kernel_miner.util.ExpressionFormatException;
import de.uni_hildesheim.sse.kernel_miner.util.Files;
import de.uni_hildesheim.sse.kernel_miner.util.Logger;
import de.uni_hildesheim.sse.kernel_miner.util.logic.Formula;
import de.uni_hildesheim.sse.kernel_miner.util.logic.True;
import de.uni_hildesheim.sse.kernel_miner.util.parser.Parser;

/**
 * This class utilizes TypeChef to populate {@link SourceFile}s with {@link Block}s,
 * containing their presence conditions.
 * 
 * @author Adam Krafczyk
 */
public class TypeChef {

    private static final Parser<Formula> PC_PARSER = new Parser<>(new TypeChefPresenceConditionGrammar());
    
    private File exe;
    
    private File linuxDir;
    
    private String arch;
    
    private File partialConfHeader;
    
    private File platformHeader;
    
    private File kconfigModelsDir;
    
    private List<File> postIncludeDirs;
    
    private List<File> linuxIncludeDirs;
    
    /**
     * Creates a {@link TypeChef} instance with default parameters (arch x86) that
     * should work on recent Linux versions when running on an Ubuntu machine.
     * 
     * @param linuxDir The directory of the Linux source tree.
     * @param kconfigModelsDir The directory containing the Kconfig models generated by KconfigReader.
     *      It should contain the files <code>&lt;arch&gt;.dimacs</code>, <code>&lt;arch&gt;.features</code>,
     *      <code>&lt;arch&gt;.completed.h</code> and <code>&lt;arch&gt;.nonbool.h</code>.
     */
    public TypeChef(File linuxDir, File kconfigModelsDir) {
        setExe(new File("../typechef/typechef.sh"));
        setLinuxDir(linuxDir);
        setArch("x86");
        setPartialConfHeader(new File("res/typechef/partial_conf.h"));
        setPlatformHeader(new File("res/typechef/platform.h"));
        setKconfigModelsDir(kconfigModelsDir);
        
        postIncludeDirs = new ArrayList<>();
        addDefaultPostIncludeDirs();
        
        linuxIncludeDirs = new ArrayList<>();
        addDefaultLinuxIncludeDirs();
    }
    
    /**
     * Sets the path to the TypeChef executable.
     * 
     * @param exe Path to the TypeChef executable.
     */
    private void setExe(File exe) {
        this.exe = exe;
    }
    
    /**
     * Sets the path to the Linux source tree.
     * 
     * @param linuxDir The directory of the Linux source tree.
     */
    public void setLinuxDir(File linuxDir) {
        this.linuxDir = linuxDir;
    }
    
    /**
     * Sets the architecture that should be analyzed.
     * Linux include directories need to be updated after this,
     * by calling {@link #clearLinuxIncludeDirs()} and {@link #addDefaultLinuxIncludeDirs()}.
     * 
     * @param arch The architecture that should be analyzed.
     */
    public void setArch(String arch) {
        this.arch = arch;
    }
    
    /**
     * Sets the path to a header file, containing partial configurations, that
     * will be included at the top of the source file.
     * 
     * @param partialConfHeader The partial configuration header file.
     */
    public void setPartialConfHeader(File partialConfHeader) {
        this.partialConfHeader = partialConfHeader;
    }
    
    /**
     * Sets the path to the platform header file, containing the symbols defined
     * by the compiler, that will be included at the top of the source file.
     * 
     * @param platformHeader The platform header file.
     */
    public void setPlatformHeader(File platformHeader) {
        this.platformHeader = platformHeader;
    }
    
    
    /**
     * Sets the path to the Kconfig models. It should contain the files
     * <code>&lt;arch&gt;.dimacs</code>, <code>&lt;arch&gt;.features</code>,
     * <code>&lt;arch&gt;.completed.h</code> and <code>&lt;arch&gt;.nonbool.h</code>.
     * 
     * @param kconfigModelsDir The directory containing the Kconfig models (e.g. generated by KconfigReader).
     */
    public void setKconfigModelsDir(File kconfigModelsDir) {
        this.kconfigModelsDir = kconfigModelsDir;
    }
    
    /**
     * Adds a system include directory, where TypeChef will search for header files.
     * 
     * @param postIncludeDir The system include directory.
     */
    public void addPostIncludeDir(File postIncludeDir) {
        postIncludeDirs.add(postIncludeDir);
    }
    
    /**
     * Adds the default list of system include directories. This works on an
     * Ubuntu machine.
     */
    public void addDefaultPostIncludeDirs() {
        addPostIncludeDir(new File("/usr/lib/gcc/x86_64-linux-gnu/5/include"));
        addPostIncludeDir(new File("/usr/include/x86_64-linux-gnu"));
    }
    
    /**
     * Clears the list of system include directories.
     */
    public void clearPostIncludeDirs() {
        postIncludeDirs.clear();
    }
    
    /**
     * Adds an include directory inside the Linux source tree, where TypeChef
     * will search for header files.
     * 
     * @param linuxIncludeDir The include directory, relative to the Linux source tree root.
     */
    public void addLinuxIncludeDir(File linuxIncludeDir) {
        linuxIncludeDirs.add(linuxIncludeDir);
    }
    
    /**
     * Adds the default include directories in the Linux source tree. This depends
     * on the architecture that is set via {@link #setArch(String)}. This should
     * work on recent Linux versions.
     */
    public void addDefaultLinuxIncludeDirs() {
        addLinuxIncludeDir(new File("include"));
        addLinuxIncludeDir(new File("arch/" + arch + "/include"));
        addLinuxIncludeDir(new File("arch/" + arch + "/include/generated"));
        addLinuxIncludeDir(new File("arch/" + arch + "/include/uapi"));
        addLinuxIncludeDir(new File("arch/" + arch + "/include/generated/uapi"));
        addLinuxIncludeDir(new File("arch/" + arch + "/include/asm/mach-default"));
        addLinuxIncludeDir(new File("arch/" + arch + "/include/asm/mach-generic"));
        addLinuxIncludeDir(new File("arch/" + arch + "/include/asm/mach-voyager"));
        addLinuxIncludeDir(new File("include/uapi"));
    }
    
    /**
     * Clears the list of include directories in the Linux source tree.
     */
    public void clearLinuxIncludeDirs() {
        linuxIncludeDirs.clear();
    }
    
    /**
     * Checks whether all parameters are set to sane values.
     * 
     * @throws IllegalArgumentException If any of the parameters is not set correctly.
     */
    private void checkParameters() throws IllegalArgumentException {
        if (!exe.isFile()) {
            throw new IllegalArgumentException("Executable \"" + exe + "\" does not exist");
        }
        if (!exe.canExecute()) {
            throw new IllegalArgumentException("Executable \"" + exe + "\" can't be executed");
        }
        
        if (!linuxDir.isDirectory()) {
            throw new IllegalArgumentException("linuxDir \"" + linuxDir + "\" is not a directory.");
        }
        if (!linuxDir.canRead()) {
            throw new IllegalArgumentException("linuxDir \"" + linuxDir + "\" is not readable.");
        }
        
        if (!partialConfHeader.isFile()) {
            throw new IllegalArgumentException("Partial conf header \"" + partialConfHeader + "\" does not exist");
        }
        if (!partialConfHeader.canRead()) {
            throw new IllegalArgumentException("Partial conf header \"" + partialConfHeader + "\" is not readable");
        }
        
        if (!platformHeader.isFile()) {
            throw new IllegalArgumentException("Platform header \"" + platformHeader + "\" does not exist");
        }
        if (!platformHeader.canRead()) {
            throw new IllegalArgumentException("Platform header \"" + platformHeader + "\" is not readable");
        }
        
        if (!kconfigModelsDir.isDirectory()) {
            throw new IllegalArgumentException("Kconfig dir \"" + kconfigModelsDir + "\" is not a directory");
        }
    }
    
    /**
     * Parses the output of TypeChef and populates the {@link SourceFile} with {@link Block}s
     * filled with presence conditions.
     * 
     * @param piFile The .pi file generated by the lexer of TypeChef.
     * @param sourceFile The {@link SourceFile} object representing the source file
     *      in the Linux tree, where the {@link Block}s will be addded to.
     *      
     * @throws IOException If reading the .pi file fails.
     */
    private void parseOutput(File piFile, SourceFile sourceFile) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(piFile));
        
        Block currentBlock = null;
        String currentLocation = sourceFile.getPath().getPath();
        
        
        String line;
        int lineNumber = 0;
        while ((line = in.readLine()) != null) {
            lineNumber++;
            
            if (line.startsWith("#line")) {
                String[] parts = line.split(" ");
                currentLocation = parts[2].substring(1, parts[2].length() - 1);
                currentLocation = Files.relativize(new File(currentLocation), linuxDir);
                
            } else if (line.startsWith("#if")) {
                String pcStr = line.substring(4);
                
                Formula pc = new True();
                try {
                    pc = PC_PARSER.parse(pcStr);
                } catch (ExpressionFormatException e) {
                    Logger.INSTANCE.logException("Can't parse presence condition " + pcStr, e);
                }
                
                Block newBlock = new Block(pc, currentLocation, lineNumber);
                if (currentBlock != null) {
                    currentBlock.setNext(newBlock);
                }
                currentBlock = newBlock;
                if (sourceFile.getFirstBlock() == null) {
                    sourceFile.setFirstBlock(currentBlock);
                }
                
            } else if (line.startsWith("#endif")) {
                Block newBlock = new Block(new True(), currentLocation, lineNumber);
                currentBlock.setNext(newBlock);
                currentBlock = newBlock;
                
            } else {
                if (currentBlock == null) {
                    currentBlock = new Block(new True(), currentLocation, lineNumber);
                }
                if (sourceFile.getFirstBlock() == null) {
                    sourceFile.setFirstBlock(currentBlock);
                }
                currentBlock.addLine(line);
            }
        }
        
        in.close();
        
        if (sourceFile.getFirstBlock() != null) {
        
            // remove empty blocks, i.e. blocks generated between #endif and #if with nothing in between
            currentBlock = sourceFile.getFirstBlock();
            while (currentBlock != null) {
                
                Block next = currentBlock.getNext();
                while (next != null && next.getLines().size() == 0) {
                    next = next.getNext();
                }
                
                currentBlock.setNext(next);
                currentBlock = next;
            }
        
        }
        
    }
    
    /**
     * Runs TypeChef on a single {@link SourceFile} in the Linux source tree.
     * the {@link SourceFile} will be filled with {@link Block}s containing the
     * presence conditions.
     * 
     * @param file The {@link SourceFile} in the Linux source tree.
     * 
     * @throws IOException If running the TypeChef process or reading its output fails.
     * @throws IllegalArgumentException If any of the parameters in this object are faulty.
     */
    public void runOnFile(SourceFile file) throws IOException, IllegalArgumentException {
        checkParameters();
        
        File output = new File(file.getPath().getPath().replace('/', '.'));
        if (!output.mkdir()) {
            Logger.INSTANCE.logError("Can't create directory " + output.getAbsolutePath());
            return;
        }
        File piFile = new File(output, "chef.pi");
        
        List<String> command = new ArrayList<>();
        command.add(exe.getAbsolutePath());
        command.add("--platfromHeader=" + platformHeader.getAbsolutePath());
        for (File postIncludeDir : postIncludeDirs) {
            command.add("--postIncludes=" + Files.relativize(postIncludeDir, new File("/")));
        }
        command.add("--lex");
        command.add("--prefixonly=CONFIG_");
        command.add("--output=" + new File(output, "chef").getAbsolutePath());
        command.add("--writePI");
        command.add("--no-analysis");
        if (file.getPresenceCondition() != null) {
            File pc = new File(output, "file.pc");
            
            try {
                BufferedWriter writer = new BufferedWriter(new FileWriter(pc));
                writer.write(file.getPresenceCondition().toString()); // TODO: format
                writer.newLine();
                writer.close();
                
                command.add("--filePC=" + pc.getAbsolutePath());
            } catch (IOException e) {
                Logger.INSTANCE.logException("Can't write presence condition file", e);
            }
            
        }
        command.add("--featureModelDimacs=" + new File(kconfigModelsDir, arch + ".dimacs").getAbsolutePath());
        command.add("--openFeat=" + new File(kconfigModelsDir, arch + ".features").getAbsolutePath());
        command.add("--include=" + new File(kconfigModelsDir, arch + ".completed.h").getAbsolutePath());
        command.add("--include=" + new File(kconfigModelsDir, arch + ".nonbool.h").getAbsolutePath());
        command.add("--include=" + partialConfHeader.getAbsolutePath());
        for (File linuxIncludeDir : linuxIncludeDirs) {
            command.add("--incdir=" + new File(linuxDir, linuxIncludeDir.getPath()).getAbsolutePath());
        }
        command.add(new File(linuxDir, file.getPath().getPath()).getAbsolutePath());
        
        
        ProcessBuilder builder = new ProcessBuilder(command);
        
        // TODO: for debug only
        builder.redirectOutput(Redirect.to(new File(output, "stdout.log")));
        builder.redirectError(Redirect.to(new File(output, "stderr.log")));
        
        Process chef = builder.start();
        
        int status = -1;
        try {
            status = chef.waitFor();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if (status != 0) {
            String[] lines = new String[command.size() + 2];
            lines[0] = "A typechef instance exited with status: " + status;
            lines[1] = "The command was: ";
            for (int i = 0; i < command.size(); i++) {
                lines[i + 2] = command.get(i);
            }
            Logger.INSTANCE.logError(lines); 
            return;
        }
        
        parseOutput(piFile, file);
        
        piFile.delete();
    }
    
}
